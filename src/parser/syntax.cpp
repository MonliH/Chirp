/*
Phase 3: Syntax analysis parser

This is the actual parser(but I didn't call it that). It reads the tokens generated by the lexer, and generates a parse tree.
This should use a bottom up parsing algorithm, but I'm not sure which.
*/
#include "syntax.h"
#include <memory>
#include "../cli/log.h"
#include <iostream>

// I have no idea if this is ok, but this seems to work
namespace syntax
{
    parser* local_env; // *munchii is triggered*
    tree* local_tree;
    std::unique_ptr<node> current_node;

    bool match(token_name t)
    {
        if(local_env->getToken().name == t)
        {
            local_env->nextToken();
            return true;
        }
        else
        {
            return false;
        }
        
    }

    bool expect(token_name t)
    {
        if(match(t))
        {
            return true;
        }
        else
        {
            // TO-DO: An error handler
            cli::log(ERROR,"Unexpected token");
            return false;
        }
    }

    // === Grammar ===
    /*
    The grammar something like this

    Statement -> Declaration
    Declaration -> data_type(token) Variable_Declaration
    Variable_Declaration -> confirm(token) identifier(token)

    For the moment I am using an handwritten grammar but I migt write a simple parser generator to make it easier.
    */

    void var_decl()
    {
       if(local_env->getToken().name == token_name::confirm)
       {
           cli::log(DEBUG,"Matched confirm token");
           if(local_env->lookAhead().name == token_name::identifier)
           {
               cli::log(DEBUG,"Matched identifier token");
               // btw when I write a variable with a name like namel, the l is for litteral
               auto name = std::make_unique<node>("identifier");
               auto namel = std::make_unique<node>(local_env->lookAhead().value);
               name->addChild(std::move(namel));
               current_node->getChild(0).addChild(std::move(name));
           }
       }
    }

    bool decl()
    {
        if(local_env->getToken().name == token_name::data_type)
        {
            auto decl = std::make_unique<node>("declaration");

            auto spec = std::make_unique<node>("specifier");
            auto type = std::make_unique<node>("data_type");
            auto typel = std::make_unique<node>(local_env->getToken().value);
            
            type->addChild(std::move(typel));
            spec->addChild(std::move(type));
            decl->addChild(std::move(spec));
            current_node->addChild(std::move(decl));

            local_env->nextToken();
            var_decl();

            return true;
        }
        else
        {
            cli::log(DEBUG,"Not a declaration");
            return false;
        }
    }

    void stat()
    {
        auto& rootptr = local_tree->getRoot();
        current_node = std::make_unique<node>("statement");
        if(decl())
        {
            rootptr.addChild(std::move(current_node));
        }
        else
        {
            if(match(token_name::end_of_string))
            {
                cli::log(DEBUG,"Reached end");
            }
            else
            {
                cli::log(ERROR,"Unrecognized statement");   
            }
            local_env->nextToken();
        }
    }

    void parse(parser* p,tree* t)
    {
        cli::log(DEBUG,"--===-- SYNTAX ANALYSIS --===--");
        auto root = std::make_unique<node>("root");
        t->setRoot(std::move(root));

        local_tree = t;
        local_env = p;

        // For the moment can only parse one statement
        while(local_env->getToken().name != token_name::end_of_string)
        {
            stat();
        }
        // rootptr.addChild(std::move(statement));
    }
}

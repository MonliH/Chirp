/*
Phase 3: Syntax analysis parser

This is the actual parser(but I didn't call it that). It reads the tokens generated by the lexer, and generates a parse tree.
This should use a bottom up parsing algorithm, but I'm not sure which.
*/
#include "syntax.h"
#include <memory>
#include "../cli/log.h"
#include <iostream>

// I have no idea if this is ok, but this seems to work
namespace syntax
{
    parser* local_env; // *munchii is triggered*
    tree* local_tree;
    std::unique_ptr<node> current_node;

    bool match(token_name t)
    {
        if(local_env->getToken().name == t)
        {
            local_env->nextToken();
            return true;
        }
        else
        {
            return false;
        }
        
    }

    bool expect(token_name t)
    {
        if(match(t))
        {
            return true;
        }
        else
        {
            // TO-DO: An error handler
            cli::log(cli::log_level::error,"Unexpected token");
            return false;
        }
    }

    // === Grammar ===
    /*
    The grammar something like this

    Statement -> Declaration
    Statement -> Assign

    Declaration -> data_type(token) Variable_Declaration
    Variable_Declaration -> confirm(token) identifier(token)

    Assign -> (backtrack) identifier(token) =(token) Expresssion

    Expression -> litteral
    Expression -> identifier
    Expression -> identifier operator(token) identifier
    Expression -> litteral operator(token) litteral

    For the moment I am using an handwritten grammar but I migt write a simple parser generator to make it easier.
    */
   // Variable declaration
    void var_decl()
    {
       if(local_env->getToken().name == token_name::confirm)
       {
           cli::log(cli::log_level::debug, "Matched confirm token");
           // Doesn't match, because we don't want to lose it yet
           if(local_env->lookAhead().name == token_name::identifier)
           {
               cli::log(cli::log_level::debug, "Matched identifier token");
               // btw when I write a variable with a name like namel, the l is for litteral
               auto name = std::make_unique<node>("identifier");
               auto namel = std::make_unique<node>(local_env->lookAhead().value);
               name->addChild(std::move(namel));
               current_node->getChild(0).addChild(std::move(name));
           }
       }
    }
    // Declaration
    bool decl()
    {
        if(local_env->getToken().name == token_name::data_type)
        {
            auto decl = std::make_unique<node>("declaration");

            auto spec = std::make_unique<node>("specifier");
            auto type = std::make_unique<node>("data_type");
            auto typel = std::make_unique<node>(local_env->getToken().value);
            
            type->addChild(std::move(typel));
            spec->addChild(std::move(type));
            decl->addChild(std::move(spec));
            current_node->addChild(std::move(decl));

            local_env->nextToken();
            var_decl();

            return true;
        }
        else
        {
            cli::log(cli::log_level::debug, "Not a declaration");
            return false;
        }
    }

    // Expression
    void exp()
    {
        // Could replace it by a really smart for loop

        if(match(token_name::litteral))
        {
            auto source = std::make_unique<node>("target");
            auto expr = std::make_unique<node>("expression");
            auto lit = std::make_unique<node>("litteral");
            auto litl = std::make_unique<node>(local_env->lookBehind().value);

            lit->addChild(std::move(litl));
            expr->addChild(std::move(lit));
            source->addChild(std::move(expr));
            current_node->getChild(0).addChild(std::move(source));
        }
        else
        {
        }
    }

    // Assignment
    bool assign()
    {
        if(match(token_name::identifier))
        {   
            cli::log(cli::log_level::debug, "Identifier matched");
            if(match(token_name::assign_op))
            {
                cli::log(cli::log_level::debug, "Assignement operator matched");
                auto assign = std::make_unique<node>("assignment");
                auto target = std::make_unique<node>("target");
                auto id = std::make_unique<node>("identifier");
                auto idl = std::make_unique<node>(local_env->getToken().value);

                id->addChild(std::move(idl));
                target->addChild(std::move(id));
                assign->addChild(std::move(target));
                current_node->addChild(std::move(assign));

                // local_env->nextToken();
                exp();
                return true;
            }
            return false;
        }
        return false;
    }

    // Statement
    void stat()
    {
        auto& rootptr = local_tree->getRoot();
        current_node = std::make_unique<node>("statement");
        if(decl())
        {
            rootptr.addChild(std::move(current_node));
        }
        else if(assign())
        {
            rootptr.addChild(std::move(current_node));
        }
        else
        {
            if(match(token_name::end_of_string))
            {
                cli::log(cli::log_level::debug, "Reached end");
            }
            else
            {
                cli::log(cli::log_level::error, "Unrecognized statement, with token value:" + local_env->getToken().value);   
            }
            local_env->nextToken();
        }
    }

    void parse(parser* p,tree* t)
    {
        cli::log(cli::log_level::debug,"--===-- SYNTAX ANALYSIS --===--");
        auto root = std::make_unique<node>("root");
        t->setRoot(std::move(root));

        local_tree = t;
        local_env = p;

        // For the moment can only parse one statement
        while(local_env->getToken().name != token_name::end_of_string)
        {
            stat();
        }
        // rootptr.addChild(std::move(statement));
    }
}

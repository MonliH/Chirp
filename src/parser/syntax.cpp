/*
Phase 3: Syntax analysis parser

This is the actual parser(but I didn't call it that). It reads the tokens generated by the lexer, and generates a parse tree.
This should use a bottom up parsing algorithm, but I'm not sure which.
*/
#include "syntax.h"
#include <memory>
#include "../cli/log.h"
#include <iostream>

/*
Test grammar

Statement
Stat -> Decl
Decl -> data_type VarDec

VarDec -> confirm identifier
*/

// I have no idea if this is ok, but this seems to work
namespace syntax
{
    parser* local_env; // *munchii is triggered*
    tree* local_tree;

    bool match(token t)
    {
        if(local_env->getToken().name == t.name)
        {
            local_env->nextToken();
            return true;
        }
        else
        {
            return false;
        }
        
    }

    bool expect(token t)
    {

    }

    // === Handwritten grammar(probably temporary) ===

    void Vardec()
    {
        if(local_env->getToken().name == token_name::confirm)
        {
            if(local_env->lookAhead().name == token_name::identifier)
            {
                std::cout<<"Variable matched"<<std::endl;
            }
        }
    }

    bool Decl()
    {
        if(local_env->getToken().name == token_name::data_type)
        {
            local_env->nextToken();
            Vardec();
            return true;
        }
        else
        {
            return false;
        }
    }

    void Stat()
    {
        if(Decl())
        {
        cli::log(LOG,"Ok, so two nodes should have been added to the tree");

        auto& root = local_tree->getRoot();
        std::cout << __PRETTY_FUNCTION__ << "*root = " << root.value << "\n";

        auto statement = std::make_unique<node>("statement");
        auto declaration = std::make_unique<node>("declaration");

        statement->addChild(std::move(declaration));
        root.addChild(std::move(statement));

        }
        else
        {
            // welp
        }
    }

    void parse(parser* p,tree* t)
    {
        auto root = std::make_unique<node>("root");
        t->setRoot(std::move(root));

        local_tree = t;
        local_env = p;

        Stat();
    }
}

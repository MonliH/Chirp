/*
Phase 3: Syntax analysis parser

This is the actual parser(but I didn't call it that). It reads the tokens generated by the lexer, and generates a parse tree.
This should use a bottom up parsing algorithm, but I'm not sure which.
*/
#include "syntax.h"
#include <memory>
#include "../cli/log.h"
#include <iostream>

// I have no idea if this is ok, but this seems to work
namespace syntax
{
    parser* local_env; // *munchii is triggered*
    tree* local_tree;

    bool match(token t)
    {
        if(local_env->getToken().name == t.name)
        {
            local_env->nextToken();
            return true;
        }
        else
        {
            return false;
        }
        
    }

    bool expect(token t)
    {

    }

    // === Handwritten grammar(i hope it's temporary - me) ===
    /*
    Looks something like this

    Statement -> Declaration
    Declaration -> data_type(token) Variable_Declaration
    Variable_Declaration -> confirm(token) identifier(token)
    
    btw it's really simple right now
    */
    void var_decl()
    {
        if(local_env->getToken().name == token_name::confirm)
        {
            if(local_env->lookAhead().name == token_name::identifier)
            {
            }
        }
    }

    bool decl()
    {
        if(local_env->getToken().name == token_name::data_type)
        {
            local_env->nextToken();
            var_decl();
        }
        else
        {
            cli::log(DEBUG,"oof");
        }
    }

    void stat()
    {
        if(decl())
        {

        }
    }

    void parse(parser* p,tree* t)
    {
        auto root = std::make_unique<node>("root");
        t->setRoot(std::move(root));

        local_tree = t;
        local_env = p;

        auto& rootptr = local_tree->getRoot();
        // rootptr.addChild(std::move(statement));
    }
}

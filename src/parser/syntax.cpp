/*
Phase 3: Syntax analysis parser

This is the actual parser(but I didn't call it that). It reads the tokens generated by the lexer, and generates a parse tree.
This should use a bottom up parsing algorithm, but I'm not sure which.
*/
#include "syntax.h"
#include <memory>
#include "../cli/log.h"
#include <iostream>

// I have no idea if this is ok, but this seems to work
namespace syntax
{
    parser* local_env; // *munchii is triggered*
    tree* local_tree;
    std::unique_ptr<node> current_node;

    bool match(token_name t)
    {
        if(local_env->getToken().name == t)
        {
            local_env->nextToken();
            return true;
        }
        else
        {
            return false;
        }
        
    }

    bool expect(token_name t)
    {
        if(match(t))
        {
            return true;
        }
        else
        {
            // TO-DO: An error handler
            cli::log(cli::log_level::error,"Unexpected token");
            return false;
        }
    }

    // === Grammar ===
    /*
    The grammar something like this

    Statement -> Declaration
    Statement -> Assign

    Declaration -> data_type(token) Variable_Declaration
    Variable_Declaration -> confirm(token) identifier(token)

    Assign -> identifier(token) =(token) Expresssion

    Expression -> litteral
    Expression -> identifier
    Expression -> identifier operator(token) identifier
    Expression -> litteral operator(token) litteral

    For the moment I am using an handwritten grammar but I migt write a simple parser generator to make it easier.
    */
   // Variable declaration
    void var_decl()
    {
       if(local_env->getToken().name == token_name::confirm)
       {
           cli::log(cli::log_level::debug, "Matched confirm token");
           // Doesn't match, because we don't want to lose it yet
           if(local_env->lookAhead().name == token_name::identifier)
           {
               cli::log(cli::log_level::debug, "Matched identifier token");
               // btw when I write a variable with a name like namel, the l is for litteral
               auto name = std::make_unique<node>("identifier");
               auto namel = std::make_unique<node>(local_env->lookAhead().value);
               name->addChild(std::move(namel));
               current_node->getChild(0).addChild(std::move(name));
           }
       }
    }
    // Declaration
    bool decl()
    {
        if(local_env->getToken().name == token_name::data_type && local_env->lookAhead().name == token_name::confirm)
        {
            auto decl = std::make_unique<node>("declaration");

            auto spec = std::make_unique<node>("specifier");
            auto type = std::make_unique<node>("data_type");
            auto typel = std::make_unique<node>(local_env->getToken().value);
            
            type->addChild(std::move(typel));
            spec->addChild(std::move(type));
            decl->addChild(std::move(spec));
            current_node->addChild(std::move(decl));

            local_env->nextToken();
            var_decl();
            local_env->nextToken();

            return true;
        }
        else
        {
            return false;
        }
    }

    void math_op()
    {
        if(local_env->getToken().name == token_name::math_op)
        {
        //std::cout<<"works"<<std::endl;
        
        std::string optype = "";
        std::string at;
        std::string bt;       
        at = tokenToString(local_env->lookBehind().name);
        bt = tokenToString(local_env->lookAhead().name);

        token op = local_env->getToken();

        if(op.value == "+")
        {
            optype = "addition";
        }
        else if (op.value == "-")
        {
        optype = "subtraction";
        }
        else if (op.value == "/")
        {
            optype = "division";
        }
        else if(op.value == "*")
        {
            optype = "multiplication";
        }

        auto operation = std::make_unique<node>(optype);
        auto atype = std::make_unique<node>(at);
        auto btype = std::make_unique<node>(bt);
        auto al = std::make_unique<node>(local_env->lookBehind().value);
        auto bl = std::make_unique<node>(local_env->lookAhead().value);

        atype->addChild(std::move(al));
        btype->addChild(std::move(bl));
        operation->addChild(std::move(atype));
        operation->addChild(std::move(btype));

        current_node->getChild(0).getChild(1).getChild(0).addChild(std::move(operation));

        local_env->nextToken();
        local_env->nextToken();
        math_op();
        //current_node->addChild(std::move(expr));
        }
        else
        {
            std::cout<<local_env->getToken().value<<std::endl;
        }
    }

    // Expression
    void exp()
    {
        auto source = std::make_unique<node>("source"); 
        auto expr = std::make_unique<node>("expression");
       
       if(local_env->getToken().name == token_name::litteral || local_env->getToken().name == token_name::identifier)
       {
           local_env->nextToken();
           // std::cout<<"doin some silly math"<<std::endl;

           if(local_env->getToken().name == token_name::math_op)
           {
               source->addChild(std::move(expr));
               current_node->getChild(0).addChild(std::move(source));
               math_op();
           }
           else
           {
                auto operation = std::make_unique<node>("static"); // static == no operation\

                std::string t = tokenToString(local_env->lookBehind().name);

                auto type = std::make_unique<node>(t);
                auto lit = std::make_unique<node>(local_env->lookBehind().value);

                type->addChild(std::move(lit));
                operation->addChild(std::move(type));
                expr->addChild(std::move(operation));
                source->addChild(std::move(expr));
                current_node->getChild(0).addChild(std::move(source));

                //local_env->nextToken();
                //local_env->nextToken();
           }
       }
       else
       {
           std::cout<<tokenToString(local_env->getToken().name)<<std::endl;
       }
    }

    // Assignment
    bool assign()
    {
        // Assignment -> identifier(token) =(token) Expression
        // Assignement -> (backtrack) identifier(token) =(token) Expression
        if(match(token_name::identifier) || local_env->lookBehind().name == token_name::identifier)
        {   
            // Declaration and definition
            cli::log(cli::log_level::debug, "Identifier matched here");
            if(local_env->getToken().name == token_name::assign_op)
            {
                // This is the part where you get a pen and paper, because this is some complicated tree stuff
                cli::log(cli::log_level::debug, "Assignement operator matched");
                auto assign = std::make_unique<node>("assignment");
                auto target = std::make_unique<node>("target");
                auto id = std::make_unique<node>("identifier");
                auto idl = std::make_unique<node>(local_env->lookBehind().value);

                id->addChild(std::move(idl));
                target->addChild(std::move(id));
                assign->addChild(std::move(target));
                current_node->addChild(std::move(assign));
                
                local_env->nextToken();
                exp();

                return true;
            }
            return false;
        }
        return false;
    }

    // Parameters aren't arguments,
    // Parameters are in function definition
    // Arguments are in function calls 
    void param()
    {

    }

    bool function()
    {
        // func -> data_type(tkn) identifier(tkn) lparen(tkn) Param

        if(match(token_name::data_type))
        {
            if(match(token_name::identifier))
            {
                expect(token_name::lparen);
                cli::log(cli::log_level::debug,"Hell ye");
            }
        }
        return false;
    }

    // Statement
    void stat()
    {
        // Statement -> Declaration
        // Statement -> Assignment
        auto& rootptr = local_tree->getRoot();
        current_node = std::make_unique<node>("statement");

        if(decl())
        {
            rootptr.addChild(std::move(current_node));

            if(local_env->lookAhead().name == token_name::end_of_string)
            {
                local_env->nextToken();
            }
            //std::cout<<"declaration ended with "<<local_env->getToken().value<<std::endl;
        }
        else if(assign())
        {
            rootptr.addChild(std::move(current_node));
            //std::cout<<"assignment ended with "<<local_env->getToken().value<<std::endl;
        }
        else if(function())
        {

        }
        else
        {
            if(match(token_name::end_of_string))
            {
                cli::log(cli::log_level::debug, "Reached end");
            }
            else
            {
                cli::log(cli::log_level::error, "Unrecognized statement, with token value:" + local_env->getToken().value); 
            }
        }
    }

    void parse(parser* p,tree* t)
    {
        cli::log(cli::log_level::debug,"--===-- SYNTAX ANALYSIS --===--");
        auto root = std::make_unique<node>("root");
        t->setRoot(std::move(root));

        local_tree = t;
        local_env = p;

        std::string last = "";
        int stuck = 0;

        // For the moment can only parse one statement
        while(local_env->getToken().name != token_name::end_of_string)
        {
            stat();
        }
        // rootptr.addChild(std::move(statement));
    }
}
